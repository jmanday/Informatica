/*
 * This is sample code generated by rpcgen.
 * These are only templates and you can use them
 * as a guideline for developing your own functions.
 */

#include "interfaz.h"


struct listaDiccionarios *listaDic = NULL;
int prim = 0;

int *
ponerasociacion_1_svc(args1 arg1,  struct svc_req *rqstp)
{
	static int  result;
	struct diccionario *daux, *daux2;
	struct listaDiccionarios *laux, *laux2;
	char *arg2, *arg3;
	int iden, encontrado1 = 0, encontrado2 = 0;
	
	iden = arg1.i; /* identificador de la lista de diccionario */
	arg2 = arg1.c; /* clave del diccionario correspondiente */
	arg3 = arg1.v; /* valor asociado a dicha clave */

	
	if(listaDic == NULL){ /* No hay ninguna lista de diccionarios definida */
		listaDic = malloc(sizeof(listaDiccionarios)); /* reservamos memoria para una lista de diccionarios */
		listaDic->sig = NULL; /* no apunta a ningÃºn otra lista de diccionarios porque es la primera */
		listaDic->id = iden;

		daux = malloc(sizeof(diccionario)); /* reservamos memoria para el nuevo diccionario */
		daux->clave = strdup(arg2); /* le asignamos la clave */
		daux->valor = strdup(arg3); /* le asginamos su valor */
		daux->sig = NULL; /* no le sigue ningun otro diccionario ya que es el primero */

		listaDic->dic = daux; /* agregamos el diccionario a la lista de diccionarios */		
	}
	else { /* existen listas de diccionarios, vemos si ya existe la asociacion */
		prim++;
		laux = listaDic;

		do{			
			if(laux->id == iden){ /* coincide la lista de diccionarios que el usuario busca */
				encontrado1 = 1;
				daux = laux->dic; /* apuntamos al primer diccionario de la lista de diccionarios */

				do{
					if(strcmp(daux->clave,arg2) == 0){ /* encontramos el diccionario que el usuario busca, por lo que le cambiamos el valor */
						encontrado2 = 1;
						daux->valor = strdup(arg3); /* cambiamos el valor del diccionario */
					}
					else
						daux = daux->sig;
		
				} while((daux != NULL) && (encontrado2 == 0)); /* recorremos los diccionarios hasta que no haya mas o no lo hayamos encontrado */

			}
			else /* no coindice la lista de diccionarios con la que el usuario busca*/					
				laux = laux->sig;

		} while((laux != NULL) && (encontrado1 == 0)); /* recorremos las lista de diccionarios hasta que no haya mas o no la hayamos encontrado */
	}


	if(prim > 0){
		if(encontrado1 == 0){ /* no se ha encontrado la lista de diccionarios por lo que hay que definirlo */
			laux2 = malloc(sizeof(listaDiccionarios)); /* reservamos memoria para una lista de diccionarios */
			laux2->sig = NULL; /* no apunta a ningÃºn otra lista de diccionarios porque es la primera */
			laux2->id = iden;

			daux = malloc(sizeof(diccionario)); /* reservamos memoria para el nuevo diccionario */
			daux->clave = strdup(arg2); /* le asignamos la clave */
			daux->valor = strdup(arg3); /* le asginamos su valor */
			daux->sig = NULL; /* no le sigue ningun otro diccionario ya que es el primero */
		
			laux2->dic = daux;
			laux = listaDic;
			while(laux->sig != NULL)
				laux = laux->sig;
			
			laux->sig = laux2;
			
		}
		else{
			if(encontrado2 == 0){
				daux2 = malloc(sizeof(diccionario)); /* reservamos memoria para el nuevo diccionario */
				daux2->clave = strdup(arg2); /* le asignamos la clave */
				daux2->valor = strdup(arg3); /* le asginamos su valor */
				daux2->sig = NULL; /* no le sigue ningun otro diccionario ya que es el primero */

				daux = laux->dic;
				while(daux->sig != NULL)
					daux = daux->sig;
				
				daux->sig = daux2;
			}
		}
	}

	result = encontrado2;
	return &result;
}

resultadoAsociacion *
obtenerasociacion_1_svc(args1 arg1,  struct svc_req *rqstp)
{
	
	static resultadoAsociacion  result;
	struct listaDiccionarios *laux, *laux2;
	char *arg2 = malloc(sizeof(char));
	int iden, encontrado = 0, encontrado2 = 0;
	struct diccionario *daux;

	iden = arg1.i; /* identificador de la lista de diccionario */
	arg2 = arg1.c; /* clave del diccionario correspondiente */

	laux = listaDic;
	while((laux != NULL) && (encontrado == 0)){ /* Buscamos la lista de diccionarios */
		if(laux->id == iden){
			encontrado = 1;
			laux2 = laux;
		}
		else
			laux = laux->sig;
	}

	
	if(encontrado == 1){ /* Si hemos encontrado la lista buscamos el diccionario */
		daux = laux2->dic;
		while((daux != NULL) && (encontrado2 == 0)){
			if(strcmp(daux->clave,arg2) == 0)
				encontrado2 = 1;
			else
				daux = daux->sig;
		}
	}
		
	if(encontrado2 == 0){
		result.estado = 0;
		result.resultadoAsociacion_u.val = "";
	}
	else{
		result.estado = 1;
		result.resultadoAsociacion_u.val = daux->valor;
	}

	return &result;
}

int *
borrarasociacion_1_svc(args1 arg1,  struct svc_req *rqstp)
{
	static int  result;
	struct listaDiccionarios *laux, *laux2;
	char *arg2 = malloc(sizeof(char));
	int iden, encontrado = 0, encontrado2 = 0, primer;
	struct diccionario *daux, *daux2;

	iden = arg1.i; /* identificador de la lista de diccionario */
	arg2 = arg1.c; /* clave del diccionario correspondiente */

	laux = listaDic;
	while((laux != NULL) && (encontrado == 0)){ /* Buscamos la lista de diccionarios */
		if(laux->id == iden){
			encontrado = 1;
			laux2 = laux;
		}
		else
			laux = laux->sig;
	}

	
	if(encontrado == 1){ /* Si hemos encontrado la lista buscamos el diccionario */
		daux = laux2->dic;
		daux2 = laux2->dic;
		primer = 0;
		while((daux != NULL) && (encontrado2 == 0)){
			if(strcmp(daux->clave,arg2) == 0){ /* Comparo si es la clave que quiero buscar */
				if(daux->sig != NULL){ /* Si hay mas de un diccionario en la lista detras del que queremos borrar*/
					if(primer == 0){ /* Si es el primero */
						laux2->dic = daux->sig;
						daux->sig = NULL;
					}
					else{
						daux2->sig = daux->sig;
						daux->sig = NULL;
					}
				}				
				else{ /* Si es el unico o ultimo diccionario de la lista */
					if(primer == 0)
						laux2->dic = NULL;	
					daux2->sig = NULL;
				}

				encontrado2 = 1;
				xdr_free((xdrproc_t) xdr_diccionario, (char *) daux); //liberamos la memoria

			}
			else{
				primer++;
				daux = daux->sig;
				if(primer > 1)
					daux2 = daux2->sig;
			}
		}
	}

	if(encontrado2 == 0)
		result = 0;
	else
		result = 1;

	return &result;
}

listaResultados *
enumerar_1_svc(int arg1,  struct svc_req *rqstp)
{
	static listaResultados  result;
	struct listaDiccionarios *laux;
	int encontrado = 0;

	laux = listaDic;

	while((laux != NULL) && (encontrado == 0)){  /* Recorremos todas las listas hasta encontrar la que busca el usuario */
		if(laux->id == arg1){
			encontrado = 1;
			result.listaResultados_u.diccio = laux->dic; /* Asiganamos a la union el primer diccionario de la lista */
		}
		else
			laux = laux->sig;
	}

	if(encontrado == 1) 
		result.estado = 1;
	else
		result.estado = 0;		


	return &result;
}
